(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),o=n(7),r=(n(0),n(88)),i=n(90),s={id:"step-by-step-guide",title:"Step-by-step guide"},l={unversionedId:"step-by-step-guide",id:"step-by-step-guide",isDocsHomePage:!1,title:"Step-by-step guide",description:"Load data & scripts",source:"@site/docs/step-by-step-guide.md",slug:"/step-by-step-guide",permalink:"/Robyn/docs/step-by-step-guide",editUrl:"https://github.com/facebookexperimental/Robyn/docs/step-by-step-guide.md",version:"current",sidebar:"someSidebar",previous:{title:"Quick Start",permalink:"/Robyn/docs/quick-start"},next:{title:"Ridge Regression",permalink:"/Robyn/docs/ridge-regression"}},c=[{value:"Load data &amp; scripts",id:"load-data--scripts",children:[]},{value:"Set model input variables",id:"set-model-input-variables",children:[{value:"set_country",id:"set_country",children:[]},{value:"set_dateVarName",id:"set_datevarname",children:[]},{value:"set_depVarName and set_depVarType",id:"set_depvarname-and-set_depvartype",children:[]},{value:"Set Prophet variables",id:"set-prophet-variables",children:[]},{value:"Set Baseline variables",id:"set-baseline-variables",children:[]},{value:"set_mediaVarName and set_mediaSpendName",id:"set_mediavarname-and-set_mediaspendname",children:[]},{value:"Set factor variables",id:"set-factor-variables",children:[]}]},{value:"Set global model parameters",id:"set-global-model-parameters",children:[]},{value:"Tune channel hyperparameters bounds",id:"tune-channel-hyperparameters-bounds",children:[]},{value:"Plotting and understanding results",id:"plotting-and-understanding-results",children:[{value:"f.plotSpendModel: Plotting the spend-reach fitting with Michaelis-Menten model",id:"fplotspendmodel-plotting-the-spend-reach-fitting-with-michaelis-menten-model",children:[]},{value:"f.plotHyperSamp: checking latin hypercube sampling distribution",id:"fplothypersamp-checking-latin-hypercube-sampling-distribution",children:[]},{value:"f.plotTrendSeason: Understanding trend and seasonality",id:"fplottrendseason-understanding-trend-and-seasonality",children:[]},{value:"bestAdstock: Adstock carryover and diminishing returns effects",id:"bestadstock-adstock-carryover-and-diminishing-returns-effects",children:[]},{value:"f.plotBestDecomp: Understanding the effect of baseline, media variables trend and seasonality along time",id:"fplotbestdecomp-understanding-the-effect-of-baseline-media-variables-trend-and-seasonality-along-time",children:[]},{value:"f.plotMAPEConverge: Understanding MAPE evolution per Random Search iteration and minutes spent",id:"fplotmapeconverge-understanding-mape-evolution-per-random-search-iteration-and-minutes-spent",children:[]},{value:"f.plotBestModDiagnostic: plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual",id:"fplotbestmoddiagnostic-plot-best-model-diagnostics-residual-vs-fitted-qq-plot-and-residual-vs-actual",children:[]},{value:"f.plotChannelROI: Understanding performance with spend and return of investment charts",id:"fplotchannelroi-understanding-performance-with-spend-and-return-of-investment-charts",children:[]},{value:"f.plotHypConverge: Correlation and convergence of hyperparameters and MAPE (Mean Absolute Percentage Error)",id:"fplothypconverge-correlation-and-convergence-of-hyperparameters-and-mape-mean-absolute-percentage-error",children:[]},{value:"f.plotHyperBoundOptim: Improved plot for convergence of hyperparameters and MAPE (Mean Absolute Percentage Error)",id:"fplothyperboundoptim-improved-plot-for-convergence-of-hyperparameters-and-mape-mean-absolute-percentage-error",children:[]}]},{value:"Using the optimiser",id:"using-the-optimiser",children:[]}],p={toc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"load-data--scripts"},"Load data & scripts"),Object(r.b)("p",null,"The first step is to load data and scripts, you can start with our simulated\ndata file (de_simulated_data.csv) if you want to practice at the beginning."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"script_path <- str_sub(rstudioapi::getActiveDocumentContext()$path, start = 1, end = max(unlist(str_locate_all(rstudioapi::getActiveDocumentContext()$path, \"/\"))))\ndt_input <- fread(paste0(script_path,'de_simulated_data.csv'))\nholidays <- fread(paste0(script_path,'generated_holidays.csv'))\n")),Object(r.b)("p",null,"Our script has been designed to pull files automatically from the folder where\nthe \u2018fb_nextgen_mmm.exec.R\u2019 script resides. If you would like to use a new data\ninput file instead of our simulated data you will need to save it in the same\nfolder and replace dt_input.csv file as in the example below: Before dt_input <-\nfread(paste0(script_path,'de_simulated_data.csv')) After dt_input <-\nfread(paste0(script_path,'your_input_data_file.csv'))"),Object(r.b)("h2",{id:"set-model-input-variables"},"Set model input variables"),Object(r.b)("p",null,"Once you have defined the input files to work with and loaded to the source all\nthe functions needed to run the code. You will need to define and set the input\nvariables."),Object(r.b)("h3",{id:"set_country"},"set_country"),Object(r.b)("p",null,"The first variable to declare is the country. We recommend using only one\ncountry especially if you are planning to leverage prophet for trend and\nseasonality which automatically pulls holidays for the country you have selected\nand simplifies the process."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_country <- "DE" # only one country allowed. Used in prophet holidays\n')),Object(r.b)("h3",{id:"set_datevarname"},"set_dateVarName"),Object(r.b)("p",null,'For date variables you must have in mind that the DATE column in your dataset\nhas to be in "yyyy-mm-dd " format. ie. "2020-01-01"'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_dateVarName <- c("DATE") # date must be format "2020-01-01"\n')),Object(r.b)("h3",{id:"set_depvarname-and-set_depvartype"},"set_depVarName and set_depVarType"),Object(r.b)("p",null,"Setting the dependent variable is basically the outcome you are trying to\nmeasure. We only accept one dependent variable under set_depVarName. This\nvariable can take the form of revenue (Sales or profit in monetary values) or\nconversion (Number of transactions, units sold) which you will indicate when\ndefining the set_depVarType variable."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_depVarName <- c("revenue") # there should be only one dependent variable\nset_depVarType <- "revenue" # "revenue" or "conversion" are allowed\n')),Object(r.b)("h3",{id:"set-prophet-variables"},"Set Prophet variables"),Object(r.b)("h4",{id:"activate_prophet"},"activate_prophet"),Object(r.b)("p",null,"First you will need to indicate the model if you would like to turn on or off\nthe Prophet feature in the code to be used for seasonality, trend and holidays.\nT (True) means it is activated and F (False) deactivated."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"activate_prophet <- T\n")),Object(r.b)("h4",{id:"set_prophet"},"set_prophet"),Object(r.b)("p",null,'The next step is to select which of the provided outcomes of Prophet you will\nuse in the model. It is recommended to at least keep trend and holidays. Please\nhave in mind that "trend","season", "weekday", "holiday" are provided and\ncase-sensitive.'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_prophet <- c("trend", "season", "holiday")\n')),Object(r.b)("h4",{id:"set_prophetvarsign"},"set_prophetVarSign"),Object(r.b)("p",null,'You may define the variable sign control for prophet variables to be "default",\n"positive", or "negative". If you are expecting coefficients for prophet\nvariables such as "trend", "season", "holiday" to be default (either positive or\nnegative), positive or negative. We recommend using default. Please remember the\nobject declared must be same length as set_prophet\u2019s'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_prophetVarSign <- c("default","default", "default")\n')),Object(r.b)("h4",{id:"test-and-visualise-prophets-decomposition"},"Test and visualise prophet\u2019s decomposition"),Object(r.b)("p",null,"You may drill-down into prophet results to understand better the outcomes\nprovided by the tool by executing the following command."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"f.getProphet(dt_input)\n")),Object(r.b)("h3",{id:"set-baseline-variables"},"Set Baseline variables"),Object(r.b)("p",null,"The following step is to set the baseline variables which typically are things\nlike competitors, pricing, promotions, temperature, unemployment rate and any\nother variable that is not media exposure but has a strong relationship with\nsales outcomes. You will need to indicate the model if you would like to turn on\nor off baseline variables in the code. T (True) means it is activated and F\n(False) deactivated."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"activate_baseline <- T\n")),Object(r.b)("p",null,"You may then define the different baseline variables you would like to consider."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_baseVarName <- c("promotions", "price changes", "competitors sales")\n')),Object(r.b)("p",null,'You may apply sign control for baseline variables to be "default", "positive",\nor "negative". If you are expecting coefficients for baseline variables such as\n"promotions", "price changes", "competitors sales" to be default (either\npositive or negative), positive or negative depending on its expected\nrelationship with the dependent variable. For example, rainy weather may have a\npositive or negative impact in sales depending on the business. Please remember\nthe object declared must be same length as set_baseVarName\u2019s'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_baseVarSign <- c("negative") # c("default", "positive", and "negative")\n')),Object(r.b)("h3",{id:"set_mediavarname-and-set_mediaspendname"},"set_mediaVarName and set_mediaSpendName"),Object(r.b)("p",null,"There is one key restriction to have in mind here, you must have spend variables\ndeclared for every media channel you would like to measure. So they have to be\nin the same order and same length as set_mediaVarName variables."),Object(r.b)("p",null,"Correct"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_mediaVarName <- c("tv_S"    ,"ooh_S",   "print_S"   ,"facebook_I"   ,"search_clicks_P")\n\nset_mediaSpendName <- c("tv_S"  ,"ooh_S",   "print_S"   ,"facebook_S"   ,"search_S")\n')),Object(r.b)("p",null,"Incorrect"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_mediaVarName <- c("tv_S"    ,"ooh_S",   "print_S"   ,"facebook_I"   ,"search_clicks_P")\n\nset_mediaSpendName <- c("tv_S"  ,"ooh_S",   "print_S")\n')),Object(r.b)("h4",{id:"set_mediavarsign"},"set_mediaVarSign"),Object(r.b)("p",null,'You may apply sign control for media variables to be "default", "positive", or\n"negative". If you are expecting coefficients for baseline variables such as\n"tv", "print", "facebook" to be default (either positive or negative), positive\nor negative depending on its expected relationship with the dependent variable.\nWe recommend using positive for all. Please remember the object declared must be\nsame length as set_mediaVarName\u2019s'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'set_mediaVarSign <- c("positive", "positive", "positive", "positive", "positive")\n')),Object(r.b)("h3",{id:"set-factor-variables"},"Set factor variables"),Object(r.b)("p",null,"If any variable above should be factor please include it in this section of the\ncode, otherwise leave it empty as by default \u201cc()\u201d"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"set_factorVarName <- c()\n")),Object(r.b)("h2",{id:"set-global-model-parameters"},"Set global model parameters"),Object(r.b)("p",null,"In this section you will have to define parameters values and bounds for the\nmodel to start working:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("strong",{parentName:"p"},"number of cores")," in your computer to be used for ",Object(r.b)("strong",{parentName:"p"},"parallel\ncomputing"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("strong",{parentName:"p"},"data training size")," (set_modTrainSize) which will indicate the\npercentage of data to be used to train the model, therefore, the percentage\nleft (1- training size) to validate the model."),Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},"The function f.plotTrainSize helps you select the best split. Set the\nfunction to f.plotTrainSize(TRUE) to plot the Bhattacharyya coefficient,\nan indicator for the similarity of two distributions, for the training\nsize 50-90%. The higher the Bhatta coefficient, the more similar the train\nand test data splits and thus the better the potential model fit in the\nend."))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The adstocking method which can be\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Geometric_distribution"}),"Geometric")," or\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Weibull_distribution"}),"Weibull")," distributions.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("strong",{parentName:"p"},"number of iterations")," (set_iter) your model will have to find optimum\nvalues for coefficients.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("strong",{parentName:"p"},"hyperparameters bounds")," which we recommend to leave as default but can\nbe changed according to learnings from model iterations and analysts\u2019 past\nexperience."),Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"The definition of each hyperparameter:")),Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Thetas"),": Geometric function decay rate"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Shapes"),": Weibull parameter that controls the decay shape between\nexponential and s-shape"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Scales"),": Weibull parameter that controls the position of inflection\npoint"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Alphas"),": Hill function (Diminishing returns) parameter that controls\nthe shape between exponential and s-shape"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Gammas"),": Hill function (Diminishing returns) parameter that controls\nthe scale of transformation"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Lambdas"),": Regularization penalty parameter for ridge regression"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Understanding how adstock affects media transformation:")),Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},"In order to make more informed decisions to define hyperparameter\nvalues, it\u2019s very helpful to know which hyperparameter is doing what\nduring the media transformation. The plot function f.plotAdstockCurves\nhelps you understand exactly that."),Object(r.b)("li",{parentName:"ol"},"Below is the geometric adstock that is a one parameter (theta)\nfunction. Assume the time unit is week, then we can see that when\ntheta=0.9, meaning 90% of the media effect this week carries over to\nthe next week, the halflife enters after 8 weeks (halflife value in\nlegend). In other words, it takes 8 weeks until the media effect decays\nto half when theta=0.9. This should help you having a more tangible\nfeeling about if the theta value for this certain channel makes normal\nsense.")))))),Object(r.b)("img",{alt:"adstockintro chart",src:Object(i.a)("/img/adstockintro.png")}),Object(r.b)("p",null,"Similar to above, this plot visualises the two-parameter (scale & shape) Weibull\nfunction. The upper plot shows changes in scale while keeping shape constant. We\ncan observe that the larger the scale, the later the inflexion point. When\nscale=0.5 and shape = 2, it takes 18 weeks until the media effect decays to half\n(see legend). The lower plot shows changes in shape while keeping scale\nconstant. When shape is smaller, the curve rather takes on the L-shape. When\nshape is larger, the curve rather takes on S-shape."),Object(r.b)("img",{alt:"adstockintro2 chart",src:Object(i.a)("/img/adstockintro2.png")}),Object(r.b)("p",null,"In order to start setting model parameters we recommend to start with the\nGeometric function."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'## set model core features\nadstock <- "geometric"\n')),Object(r.b)("p",null,"This function is simpler and therefore easier to understand compared to the\nweibull function. You may start by focusing on Thetas\u2019 bounds, which controls\nfor the decay rate any channel could take. If you are not sure about decay rates\nfor your channels, we suggest you start with a range: thetas = c(0, 0.5). This\nmeans that in a week by week dataset, we would be expecting a maximum carryover\neffect of 50% of previous week\u2019s values to be extended and added to the\nfollowing week\u2019s values for the dependent variable (Sales, impressions, etc.)"),Object(r.b)("p",null,"Once you run one of the iterations you may notice theta's values and if certain\noptimums have been found by looking into variables including 'thetas' on their\nnames and identifying the number of times an optimum was found (epoch.optim)."),Object(r.b)("img",{alt:"coderesults1 chart",src:Object(i.a)("/img/coderesults1.png")}),Object(r.b)("p",null,"In the example above, you will see that Facebook and TV thetas are still missing\nan optimum given that optim.found column has still TRUE values on it, for this\nwe suggest to increase epoch number to Inf (Infinity) until an optimum is found."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"model_output <- f.mmmRobyn(set_hyperBoundGlobal\n                          ,set_iter = set_iter\n                          ,set_cores = set_cores\n                          ,epochN = Inf # set to Inf to auto-optimise until no optimum found\n                          ,optim.sensitivity = 0 # must be from -1 to 1. Higher sensitivity means finding optimum easier\n                          ,temp.csv.path = '/Users/leonelsentana/Documents/mmm.tempout.csv' # output optimisation result for each epoch. Use getwd() to find path\n                          )\n")),Object(r.b)("p",null,"Below an example reaching optimum in 33 epochs:"),Object(r.b)("img",{alt:"coderesults2 chart",src:Object(i.a)("/img/coderesults2.png")}),Object(r.b)("p",null,"You may note all parameters state FALSE which means there are not any more\noptimums to find. This indicates that the values found are optimal, and that if\nwanted, you could use some of these mode values to fix hyperparameter values in\nthe #### tune channel hyperparameters bounds section."),Object(r.b)("h2",{id:"tune-channel-hyperparameters-bounds"},"Tune channel hyperparameters bounds"),Object(r.b)("p",null,"For that you will need to set the following command to TRUE:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"activate_hyperBoundLocalTuning <- T\n")),Object(r.b)("p",null,"This command will enable you to define the bounds each media\u2019s parameter should\nhave manually. Please uncomment the following section of the code and define the\nvalues. Each bound can be either a range (e.g c(0.1,0.9)) or a fixed value:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{})," set_hyperBoundLocal <- list(\n   facebook_I_alphas = c(0.8356271, 0.8371774)\n   ,facebook_I_gammas = c(0.8991811, 0.9012183)\n   ,facebook_I_thetas = c(0.8700282)\n   ,ooh_S_alphas = c(0.8348503)\n   ,ooh_S_gammas = c(0.3565417)\n   ,ooh_S_thetas = c(0.3815053)\n   ,print_S_alphas = c(0.6490568)\n   ,print_S_gammas = c(0.1165910, 0.1171953)\n   ,print_S_thetas = c(0.7617390)\n   ,tv_S_alphas = c(2.4880460)\n   ,tv_S_gammas = c(0.8867124)\n   ,tv_S_thetas = c(0.1477954, 0.1478531)\n   ,search_clicks_P_alphas = c(0.1360708)\n   ,search_clicks_P_gammas = c(0.4177802)\n   ,search_clicks_P_thetas = c(0.5784685)\n )\n")),Object(r.b)("p",null,"The hyperparameters tuning section is especially handy when we know there is an\nexpected behavior behind parameters e.g. adstocking for TV decay rate taking\nonly a value within a range. In this case, we would recommend you to guide the\nmodel towards a solution that is both optimal and meets your needs based on\nexperience from previous analyses."),Object(r.b)("img",{alt:"coderesults2 chart",src:Object(i.a)("/img/coderesults2.png")}),Object(r.b)("p",null,"If we consider our previous example, it could be the case where you may want to\ntune Theta decay rates to control for the adstocking decay pacing of TV to\n",Object(r.b)("strong",{parentName:"p"},"tv_S_thetas = c(0.25, 0.35)"),". If we also fix other values where optimums have\nbeen reached, we would reach something like the example below with fix values\nand ranges based on previous iterations and past experience:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'#Please uncomment set_hyperBoundLocal list completely and use scales and shapes only if you\n#have selected \u2018adstock <- "weibull"\u2019. If you selected adstock <- "geometric" as by default, then simply #use alphas, gammas and thetas for each channel.\n\n set_hyperBoundLocal <- list(\n   facebook_I_alphas = c(0.8356271, 0.8371774)\n   ,facebook_I_gammas = c(0.8991811, 0.9012183)\n   ,facebook_I_thetas = 0.8700282\n   ,ooh_S_alphas = 0.8348503\n   ,ooh_S_gammas = 0.3565417\n   ,ooh_S_thetas = 0.3815053\n   ,print_S_alphas = 0.6490568\n   ,print_S_gammas = c(0.1165910, 0.1171953)\n   ,print_S_thetas = 0.7617390\n   ,search_clicks_P_alphas = 0.1360708\n   ,search_clicks_P_gammas = 0.4177802\n   ,search_clicks_P_thetas = 0.5784685\n   ,tv_S_alphas = 2.4880460\n   ,tv_S_gammas = 0.8867124\n   ,tv_S_thetas = c(0.25, 0.35)\n )\n')),Object(r.b)("p",null,"If we apply the above bounds to our media related variables, you may see that\nresults now reach an optimum much faster, after only 2 epochs instead of 33. You\nmay also observe that the new bounds for ",Object(r.b)("strong",{parentName:"p"},"tv_S_thetas = c(0.25, 0.35)")," have\nbeen applied, therefore the new optimum found is 0.2706085 instead of the\n0.1478256 from the previous example."),Object(r.b)("img",{alt:"coderesults3 chart",src:Object(i.a)("/img/coderesults3.png")}),Object(r.b)("h2",{id:"plotting-and-understanding-results"},"Plotting and understanding results"),Object(r.b)("p",null,"The first thing you will have to do, is to set every plot you would like to be\ndrawn to TRUE (T):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#### Plot section\n\n## insert TRUE into plot functions to plot\nf.plotSpendModel(F)\nf.plotHyperSamp(F, channelPlot = set_mediaVarName) # plot latin hypercube hyperparameter sampling balance. Max. 3 channels per plot\nf.plotTrendSeason(F) # plot prophet trend, season and holiday decomposition\nbestAdstock <- f.plotMediaTransform(T, channelPlot = set_mediaVarName) # plot best model media transformation with 3 plots: adstock decay rate, adstock effect & response curve. Max. 3 channels per plot\nf.plotBestDecomp(F) # plot best model decomposition with 3 plots: sales decomp, actual vs fitted over time, & sales decomp area plot\nf.plotMAPEConverge(F) # plot RS MAPE convergence, only for random search\nf.plotBestModDiagnostic(F) # plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual\nf.plotChannelROI(F)\nf.plotHypConverge(F, channelPlot = set_mediaVarName) # plot hyperparameter vs MAPE convergence. Max. 3 channels per plot\nboundOptim <- f.plotHyperBoundOptim(F, channelPlot = set_mediaVarName, model_output, kurt.tuner = optim.sensitivity)  # improved hyperparameter plot to better visualise trends in each hyperparameter\n")),Object(r.b)("p",null,"After that, you may execute each plot separately and analyze it."),Object(r.b)("h3",{id:"fplotspendmodel-plotting-the-spend-reach-fitting-with-michaelis-menten-model"},"f.plotSpendModel: Plotting the spend-reach fitting with Michaelis-Menten model"),Object(r.b)("p",null,"The plot below illustrates how to better translate the relationship between\nspend and reach so that you can apply it to performance ROI (Revenue/spend)\ncalculations. It is possible to choose reach variables (GRP, impressions, actual\nreach, etc.) in the model. Understanding that relationship can help with the\ntranslation of reach to spend and vice versa. LM (Linear Model) and NLS\n(Non-linear least squares) comparison shows why it is better to use a non-linear\nmodel, which is the technique applied in the code. The linear model is actually\nas primitive as just using average to scale, because in our case the intercept\nis omitted given that we assume no spend involves no reach. Whereas NLS are more\nflexible and should adapt better to the underlying correlation patterns between\nboth variables."),Object(r.b)("img",{alt:"plotSpendModel chart",src:Object(i.a)("/img/plotSpendModel.png")}),Object(r.b)("h3",{id:"fplothypersamp-checking-latin-hypercube-sampling-distribution"},"f.plotHyperSamp: checking latin hypercube sampling distribution"),Object(r.b)("p",null,"The overall idea of these charts is to validate the ",Object(r.b)("strong",{parentName:"p"},"Latin hypercube sampling\n(LHS)"),", which is a statistical method for generating a near-random sample of\nparameter values from the multidimensional distribution of hyperparameters. It\nconsists of two main charts:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Latin Hypercube Sampling distribution:")," The key aspect is to concentrate on\nthe randomness of the points on this chart. If all dots seem to cover evenly\nthe space as in the example below, then sampling is ok. However, beware of\nhigh concentrations of dots or clear areas without any dots which may mean you\nwill have to increase the sampling to have a better representation of the\nhyperspace."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Latin Hypercube Sampling distribution transformed:")," This is a half violin\nchart that represents the distribution of each media parameter values. It\nhelps you understand the actual range of values that each parameter is taking\nin order to represent uniformly the hyperparameter space. It will also depend\non the set_hyperBoundGlobal variable and its bound definitions.")),Object(r.b)("img",{alt:"plotHyperSamp chart",src:Object(i.a)("/img/plotHyperSamp.png")}),Object(r.b)("h3",{id:"fplottrendseason-understanding-trend-and-seasonality"},"f.plotTrendSeason: Understanding trend and seasonality"),Object(r.b)("p",null,"This plot describes the trend, holidays and seasonality along the analyzed\nperiod."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The ",Object(r.b)("strong",{parentName:"li"},"trend")," is the component of a time series that represents low frequency\nvariations in time. It reflects the underlying tendency behind the dependent\nvariable which can reflect growth, stability or shrinkage depending on the\ntime unit analyzed."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Holidays")," are basically days defined by governments where people\ncommemorate events which can affect consumption behaviors. Some holidays may\nhave more impact than others, therefore the different magnitudes on the chart."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Seasonality")," is a characteristic of a time series in which the time series\nexperiences regular and predictable changes that recur every calendar year.\nAny predictable fluctuation or pattern that recurs or repeats over a one-year\nperiod is said to be seasonal. Below we have the yearly seasonality as an\nexample, which shows higher demand between October and December, and lower\ndemand between April and July.")),Object(r.b)("img",{alt:"plotTrendSeason chart",src:Object(i.a)("/img/plotTrendSeason.png")}),Object(r.b)("h3",{id:"bestadstock-adstock-carryover-and-diminishing-returns-effects"},"bestAdstock: Adstock carryover and diminishing returns effects"),Object(r.b)("p",null,"This plot represents the relationship between spend or ROI, and the response\nvariable (Sales, conversions, etc.). On the first line of charts you will find:\nThe response curve which can be S or C like, its scale of growth and diminishing\nreturns pace. The profit curve which illustrates the difference between the Y\nand X axes (Response-profit). The higher this curve is on the Y axis, the closer\nto a max profit point you will get. The second line of charts displays the\nrelationship between ROI and spend, the higher the curve on the Y axis, the\ngreater the response obtained. Maximum and Average ROI are drawn for an easier\nread."),Object(r.b)("p",null,"Note: This plot admits only 3 channels at a time. Please select the 3 channels\nyou would like to analyze as in the example below where first we look at channel\nnames, and second, we indicate which names within set_mediaVarName object to\nplot c(1,2,5) :"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"set_mediaVarName\nbestAdstock <- f.plotMediaTransform(T, channelPlot = set_mediaVarName[c(1,2,5)])\n")),Object(r.b)("img",{alt:"bestAdstock chart",src:Object(i.a)("/img/bestAdstock.png")}),Object(r.b)("h3",{id:"fplotbestdecomp-understanding-the-effect-of-baseline-media-variables-trend-and-seasonality-along-time"},"f.plotBestDecomp: Understanding the effect of baseline, media variables trend and seasonality along time"),Object(r.b)("p",null,"The aim of this chart is to display the breakdown of the response variable\nthrough time and the relationship with each of its regressing components. As\nwith all marketing mix models, both media and non-media related explanatory\nfactors are displayed, including baseline effects such as price and promotions,\nas well as, trend , seasonality and holidays. In order to be able to make a\nproper description and forecast of performance, we must know to what extent each\ncomponent is present in the data."),Object(r.b)("img",{alt:"plotBestDecomp chart",src:Object(i.a)("/img/plotBestDecomp.png")}),Object(r.b)("p",null,"The chart below illustrates the contribution of each regressor variable to the\noverall response (Sales in this case) You may find for example that Facebook\nimpressions had a 7.6% contribution to overall sales which represent in total\n$28.8 million."),Object(r.b)("img",{alt:"bestDecomp2 chart",src:Object(i.a)("/img/bestDecomp2.png")}),Object(r.b)("p",null,"The next chart shows the difference between real and predicted values. The\ncloser the lines for y and y_pred, the better. You may also find RSQ and MAPE\nmetrics. RSQ or R-squared (R2) is a statistical measure that represents the\nproportion of the variance for a dependent variable that is explained by an\nindependent variable or variables in a regression model. In general terms, the\ncloser to one, the better. Whereas, the mean absolute percentage error (MAPE) is\nthe mean or average of the absolute percentage errors of forecasts. Error is\ndefined as actual or observed value minus the forecasted value. As a general\nrule, the closer to zero the better."),Object(r.b)("img",{alt:"bestDecomp3 chart",src:Object(i.a)("/img/bestDecomp3.png")}),Object(r.b)("h3",{id:"fplotmapeconverge-understanding-mape-evolution-per-random-search-iteration-and-minutes-spent"},"f.plotMAPEConverge: Understanding MAPE evolution per Random Search iteration and minutes spent"),Object(r.b)("p",null,"The chart below displays the evolution of the mean absolute percentage error\n(MAPE) with every minute spent on computing. This chart will help you understand\nhow many random search iterations to include in the model under ",Object(r.b)("strong",{parentName:"p"},"set_iter"),"\nvariable. If you increase set_iter from 100 to 10000, you will reach a point\nwhere MAPE will not decrease in time. Therefore, finding the optimum may be\nbetween 100 and 10000 may be your next step until you find the balance between\ncomputing time and MAPE reduction."),Object(r.b)("img",{alt:"plotMAPEConverge chart",src:Object(i.a)("/img/plotMAPEConverge.png")}),Object(r.b)("h3",{id:"fplotbestmoddiagnostic-plot-best-model-diagnostics-residual-vs-fitted-qq-plot-and-residual-vs-actual"},"f.plotBestModDiagnostic: plot best model diagnostics: residual vs fitted, QQ plot and residual vs. actual"),Object(r.b)("p",null,"Across these plots we analyze residuals, which are the difference between the\nobserved value of the dependent variable (y) and the predicted value (\u0177)."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Fitted vs. Residual:"),' When conducting a residual analysis, a "residuals\nversus fitted plot" is the most frequently created plot. It is a scatter plot\nof residuals on the y axis and fitted values (estimated responses) on the x\naxis. The plot is used to detect non-linearity, unequal error variances, and\noutliers. The more random the pattern for the dots distribution in this plot\nand the more horizontal the smooth line, the better, as it would mean\nlinearity, independent error variances and absence of outliers.')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"QQ Plot:")," The quantile-quantile (q-q) plot is a graphical technique to\ndetermine if two data sets come from populations with a common distribution. A\nq-q plot is a plot of the quantiles of the first data set against the\nquantiles of the second data set in this case observed Y and Y_pred. A\n45-degree reference line is also plotted. The closer the dots to the 45\ndegrees line, the better.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Observed vs. Residual:"),' Compared to the Fitted vs. Residual plot, this plot\nshows more correlation between observed/true response vs. residuals when the\nmodel R2 is lower. Normally, a certain degree of correlation here means either\nthe data is just noisy or there\u2019s still missing patterns within the error. In\nthe context of MMM, we would recommend to assume the latter one and look for\npotential additional predictors to also capture these patterns. When\nconducting a residual analysis, a "residuals versus observed plot" is commonly\nused as a complement of residual vs. fitted plots. It is a scatter plot of\nresiduals on the y axis and observed values (Actual responses) on the x axis.\nThe plot is used to detect non-linearity, unequal error variances, and\noutliers. The more uniform the dots distribution in this plot and the more\nhorizontal the smooth line, the better as it would mean independent error\nvariances and absence of outliers. The contrast between fitted and observed\nvs. residual charts helps to understand if there are common relationships\nbetween both and residuals.'))),Object(r.b)("img",{alt:"f.plotBestModDiagnostic chart",src:Object(i.a)("/img/f.plotBestModDiagnostic.png")}),Object(r.b)("h3",{id:"fplotchannelroi-understanding-performance-with-spend-and-return-of-investment-charts"},"f.plotChannelROI: Understanding performance with spend and return of investment charts"),Object(r.b)("p",null,"The plot below reflects a simple comparison of ROI and Spend per channel. The\ngreater the ROI (Return on investment) the better."),Object(r.b)("img",{alt:"plotChannelROI chart",src:Object(i.a)("/img/plotChannelROI.png")}),Object(r.b)("h3",{id:"fplothypconverge-correlation-and-convergence-of-hyperparameters-and-mape-mean-absolute-percentage-error"},"f.plotHypConverge: Correlation and convergence of hyperparameters and MAPE (Mean Absolute Percentage Error)"),Object(r.b)("p",null,"The plot below describes the relationship between mean absolute percentage error\n(MAPE) and each hyperparameter range of values. It aims to assist you in finding\nthe right Hyperparameters bounds that will help on MAPE reduction, its minimum\nvalues are indicated with a vertical line."),Object(r.b)("img",{alt:"plotHypConverge chart",src:Object(i.a)("/img/f.plotHypConverge.png")}),Object(r.b)("h3",{id:"fplothyperboundoptim-improved-plot-for-convergence-of-hyperparameters-and-mape-mean-absolute-percentage-error"},"f.plotHyperBoundOptim: Improved plot for convergence of hyperparameters and MAPE (Mean Absolute Percentage Error)"),Object(r.b)("p",null,"Similar to the previous plot, this plot illustrates the relationship between\nmean absolute percentage error (MAPE) and each hyperparameter range of values\nvia kurtosis distributions. It aims to assist you in finding the right\nHyperparameters bounds that will help on MAPE reduction, its minimum values are\nindicated with a vertical line, in this case the mode. The mode can be taken as\nthe most frequent value, therefore indicating, together with low and up vertical\nlines, the possible bounds to be adjusted on ",Object(r.b)("strong",{parentName:"p"},"set_hyperBoundLocal")," variable"),Object(r.b)("img",{alt:"f.plotHyperBoundOptim chart",src:Object(i.a)("/img/f.plotHyperBoundOptim.png")}),Object(r.b)("h2",{id:"using-the-optimiser"},"Using the optimiser"),Object(r.b)("p",null,"Optimiser is also named scenario planner. It gives you the optimum media mix,\nmeaning getting the most return out of a certain spend level, while holding true\nto a set of constraints. Please note that the optimiser will only output\nreasonable optimisation when the MMM result makes sense, meaning all media\nchannels have already found reasonable hyperparameters for adstocking and\nS-curving and the responses for each channel is meeting your expectations.\nOtherwise, the optimiser output is not interpretable. Technically, the optimiser\nconsumes the response curve (Hill function) for each channel provided by the MMM\nresult and conducts the solver for nonlinear optimisation. The gradient-based\nalgorithms (augmented Lagrangian / AUGLAG for global optimisation and Method of\nMoving Asymptotes / MMA for local optimization) are chosen to solve the\nnonlinear optimisation problem with equal and unequal constraints. For details\nsee ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/"}),"here"),"."),Object(r.b)("p",null,"Our current optimiser has two scenarios:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Maximum historical response (max_hostorical_response): Assuming two years of\ndata for five media channels is used to build the model. Total spend was 1MM \u20ac\nwith 40/30/15/10/5 split for both channels and total return was 2MM\u20ac. The\noptimiser will output the optimum split for the historical spend level of\n1MM\u20ac. For example, a maximum return of 2.5MM would be achieved with\n35/25/20/12/8 split of the 1MM\u20ac spent.")),Object(r.b)("img",{alt:"optimiser1 chart",src:Object(i.a)("/img/optimiser1.png")}),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Maximum response of expected spend (max_response_expected_soend): Compared to\nthe above, this scenario outputs the optimum split of spend for a certain\nspend level, not the historical spend level. For example, if you have 100k\u20ac\nfor the next quarter, you would define expected_spend = 100000 and\nexpected_spend_days = 90.")),Object(r.b)("img",{alt:"optimiser2 chart",src:Object(i.a)("/img/optimiser2.png")}),Object(r.b)("p",null,"For both scenarios, you must also define the constraints (lower and upper\nbounds) for each channel with the parameter channel_constr_low and\nchannel_constr_up. Assuming for channel A you\u2019ve spent 10k\u20ac per week on average,\nthen channel_constr_low = 0.7 and channel_constr_up = 1.2 will not allow the\noptimiser to go lower than 7k\u20ac or higher than 12k\u20ac for channel A when running\nthe optimisation. In general, please use realistic scenarios and avoid putting\ntoo extreme values. The optimiser is still based on your historical performance.\nFor example, if you put 10 times as much as your historical spend, the optimiser\nresult might not be making sense."),Object(r.b)("p",null,"The result would look like the following. Again, we want to address that the\nresult of optimiser will only be interpretable if the MMM result makes sense."),Object(r.b)("img",{alt:"optimiser3 chart",src:Object(i.a)("/img/optimiser3.png")}))}d.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),p=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),b=a,m=d["".concat(i,".").concat(b)]||d[b]||h[b]||r;return n?o.a.createElement(m,s(s({ref:t},c),{},{components:n})):o.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},90:function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return i}));var a=n(22),o=n(92);function r(){const{siteConfig:{baseUrl:e="/",url:t}={}}=Object(a.default)();return{withBaseUrl:(n,a)=>function(e,t,n,{forcePrependBaseUrl:a=!1,absolute:r=!1}={}){if(!n)return n;if(n.startsWith("#"))return n;if(Object(o.b)(n))return n;if(a)return t+n;const i=n.startsWith(t)?n:t+n.replace(/^\//,"");return r?e+i:i}(t,e,n,a)}}function i(e,t={}){const{withBaseUrl:n}=r();return n(e,t)}},92:function(e,t,n){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function o(e){return void 0!==e&&!a(e)}n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return o}))}}]);