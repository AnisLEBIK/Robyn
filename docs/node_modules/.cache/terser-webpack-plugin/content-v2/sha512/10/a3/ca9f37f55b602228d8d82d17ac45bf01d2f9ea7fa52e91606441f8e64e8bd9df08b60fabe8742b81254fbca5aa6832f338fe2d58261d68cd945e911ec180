{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{81:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"frontMatter\",(function(){return o})),n.d(t,\"metadata\",(function(){return c})),n.d(t,\"toc\",(function(){return s})),n.d(t,\"default\",(function(){return u}));var i=n(3),a=n(7),l=(n(0),n(88)),r=n(90),o={id:\"calibration\",title:\"Calibration using experimental results\"},c={unversionedId:\"calibration\",id:\"calibration\",isDocsHomePage:!1,title:\"Calibration using experimental results\",description:\"Calibration concept\",source:\"@site/docs/calibration.md\",slug:\"/calibration\",permalink:\"/Robyn/docs/calibration\",editUrl:\"https://github.com/facebookexperimental/Robyn/docs/calibration.md\",version:\"current\",sidebar:\"someSidebar\",previous:{title:\"Automated hyperparameter selection and optimization\",permalink:\"/Robyn/docs/automated-hyperparameter-selection-optimization\"},next:{title:\"Outputs and diagnostics\",permalink:\"/Robyn/docs/outputs-diagnostics\"}},s=[{value:\"Calibration concept\",id:\"calibration-concept\",children:[]},{value:\"Calibration in the code\",id:\"calibration-in-the-code\",children:[]}],f={toc:s};function u(e){var t=e.components,n=Object(a.a)(e,[\"components\"]);return Object(l.b)(\"wrapper\",Object(i.a)({},f,n,{components:t,mdxType:\"MDXLayout\"}),Object(l.b)(\"h3\",{id:\"calibration-concept\"},\"Calibration concept\"),Object(l.b)(\"p\",null,\"By applying results from randomized controlled-experiments, you may improve the\\naccuracy of your marketing mix models dramatically. It is recommended to run\\nthese on a recurrent basis to keep the model calibrated permanently. In general,\\nwe want to compare the experiment result with the MMM estimation of a marketing\\nchannel. Conceptually, this method is like a Bayesian method, in which we use\\nexperiment results as a prior to shrink the coefficients of media variables. A\\ngood example of these types of experiments is Facebook\\u2019s conversion lift tool\\nwhich can help guide the model towards a specific range of incremental values.\"),Object(l.b)(\"img\",{alt:\"Calibration chart\",src:Object(r.a)(\"/img/calibration1.png\")}),Object(l.b)(\"p\",null,\"Figure illustrates the calibration process above for one MMM candidate model.\\nTable below illustrates the model selection output including FB lift calibration\\nelement. Modelers can select the top models with relatively small MAPE metrics\\nas the candidates for the final model. In this example, we suggest picking model\\ntwo, as it has the minimum \",Object(l.b)(\"em\",null,\"MAPE(cal,fb)\"),\" and its \",Object(l.b)(\"em\",null,\"MAPE(holdout)\"),\"\\nis only 0.4% more than the minimum one.\"),Object(l.b)(\"h4\",{id:\"example-table\"},\"Example Table\"),Object(l.b)(\"p\",null,\"Sample output of model selection of a MMM with only two media channels, TV and\\nSocial \",Object(l.b)(\"img\",{alt:\"Calibration table\",src:Object(r.a)(\"/img/calibration2.png\")})),Object(l.b)(\"p\",null,\"Note that \",Object(l.b)(\"em\",null,\"MAPE(cal,fb)\"),\" will likely vary more widely than\"),Object(l.b)(\"em\",null,\"MAPE(holdout)\"),\" . Given this, calibration can improve performance without substantially sacrificing backtesting performance. This calibration method can be applied to other media channels which run experiments, the more channels that are calibrated, the more accurate the MMM model. \",Object(l.b)(\"em\",null,\"You may find the calibration function in the \\u2018func.R\\u2019 script.\"),Object(l.b)(\"h3\",{id:\"calibration-in-the-code\"},\"Calibration in the code\"),Object(l.b)(\"p\",null,\"So, how do we apply this in our code?\"),Object(l.b)(\"ol\",null,Object(l.b)(\"li\",{parentName:\"ol\"},\"First, we check if media channels to be calibrated actually have a media\\nvariable created.\"),Object(l.b)(\"li\",{parentName:\"ol\"},\"After that, we collect all different media to be calibrated. Consequently, we\\nloop over each lift channel (Where for each of them we iterate over all\\ndifferent studies if more than one, determining the date range of each study)\"),Object(l.b)(\"li\",{parentName:\"ol\"},\"In addition, we convert data from weeks to days (Please note the \",\"*\",\"7 in the\\nformula for mmmDays, this is assuming you will use weekly data as a basis for\\nyour model).\"),Object(l.b)(\"li\",{parentName:\"ol\"},\"Finally, and once both lift study and MMM dates are both in days, we scale\\nthe total decomposed model predicted sales into the exact number of days the\\nlift study had to be comparable with previously uploaded liftAbs number under\\nthe set_lift variable (remember liftAbs values in set_lift variable have to\\nbe absolute and measuring the same metric as the model does ie. total\\nincremental sales vs. model predicted sales)\")),Object(l.b)(\"pre\",null,Object(l.b)(\"code\",{parentName:\"pre\"},'#### Define lift calibration function\\nf.calibrateLift <- function(decompCollect, set_lift) {\\n\\n  check_set_lift <- any(sapply(set_lift$channel, function(x) any(str_detect(x, set_mediaVarName)))==F) #check if any lift channel doesn\\'t have media var\\n  if (check_set_lift) {stop(\"set_lift channels must have media variable\")}\\n  ## prep lift input\\n  getLiftMedia <- unique(set_lift$channel)\\n  getDecompVec <- decompCollect$xDecompVec\\n\\n  ## loop all lift input\\n  liftCollect <- list()\\n  for (m in 1:length(getLiftMedia)) { # loop per lift channel\\n\\n    liftWhich <- str_which(set_lift$channel, getLiftMedia[m])\\n\\n    liftCollect2 <- list()\\n    for (lw in 1:length(liftWhich)) { # loop per lift test per channel\\n\\n      ## get lift period subset\\n      liftStart <- set_lift[liftWhich[lw], liftStartDate]\\n      liftEnd <- set_lift[liftWhich[lw], liftEndDate]\\n      liftPeriodVec <- getDecompVec[DS >= liftStart & DS <= liftEnd, c(\"DS\", getLiftMedia[m]), with = F]\\n\\n      ## scale decomp\\n      mmmDays <- nrow(liftPeriodVec) * 7\\n      liftDays <- as.integer(liftEnd- liftStart + 1)\\n      y_hatLift <- sum(unlist(getDecompVec[, -1])) # total pred sales\\n      x_decompLift <- sum(liftPeriodVec[,2])\\n      x_decompLiftScaled <- x_decompLift / mmmDays * liftDays\\n\\n      ## output\\n      liftCollect2[[lw]] <- data.table(liftMedia = getLiftMedia[m] ,\\n                                       liftStart = liftStart,\\n                                       liftEnd = liftEnd,\\n                                       liftAbs = set_lift[liftWhich[lw], liftAbs],\\n                                       decompAbsScaled = x_decompLiftScaled)\\n    }\\n    liftCollect[[m]] <- rbindlist(liftCollect2)\\n  }\\n')),Object(l.b)(\"p\",null,\"The last step is to calculate the MAPE. This will be the key metric to define\\nthe model that is closest to actual incremental sales during periods for the\\nlift study. It will therefore allow us to make a decision as per the example on\\nthe \",Object(l.b)(\"a\",{parentName:\"p\",href:\"#example-table\"},Object(l.b)(\"strong\",{parentName:\"a\"},\"table\")),\".\"),Object(l.b)(\"pre\",null,Object(l.b)(\"code\",{parentName:\"pre\"},\"  ## get mape_lift\\n  liftCollect <- rbindlist(liftCollect)[, mape_lift := abs((decompAbsScaled - liftAbs) / liftAbs) * 100]\\n  return(liftCollect)\\n}\\n\")))}u.isMDXComponent=!0},88:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return u})),n.d(t,\"b\",(function(){return b}));var i=n(0),a=n.n(i);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),f=function(e){var t=a.a.useContext(s),n=t;return e&&(n=\"function\"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=f(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:\"code\",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,r=e.parentName,s=c(e,[\"components\",\"mdxType\",\"originalType\",\"parentName\"]),u=f(n),m=i,b=u[\"\".concat(r,\".\").concat(m)]||u[m]||d[m]||l;return n?a.a.createElement(b,o(o({ref:t},s),{},{components:n})):a.a.createElement(b,o({ref:t},s))}));function b(e,t){var n=arguments,i=t&&t.mdxType;if(\"string\"==typeof e||i){var l=n.length,r=new Array(l);r[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType=\"string\"==typeof e?e:i,r[1]=o;for(var s=2;s<l;s++)r[s]=n[s];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}m.displayName=\"MDXCreateElement\"},90:function(e,t,n){\"use strict\";n.d(t,\"b\",(function(){return l})),n.d(t,\"a\",(function(){return r}));var i=n(22),a=n(92);function l(){const{siteConfig:{baseUrl:e=\"/\",url:t}={}}=Object(i.default)();return{withBaseUrl:(n,i)=>function(e,t,n,{forcePrependBaseUrl:i=!1,absolute:l=!1}={}){if(!n)return n;if(n.startsWith(\"#\"))return n;if(Object(a.b)(n))return n;if(i)return t+n;const r=n.startsWith(t)?n:t+n.replace(/^\\//,\"\");return l?e+r:r}(t,e,n,i)}}function r(e,t={}){const{withBaseUrl:n}=l();return n(e,t)}},92:function(e,t,n){\"use strict\";function i(e){return!0===/^(\\w*:|\\/\\/)/.test(e)}function a(e){return void 0!==e&&!i(e)}n.d(t,\"b\",(function(){return i})),n.d(t,\"a\",(function(){return a}))}}]);","name":"8f394379.e9bbcd26.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[11],{\n\n/***/ 81:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frontMatter\", function() { return frontMatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"metadata\", function() { return metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toc\", function() { return toc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MDXContent; });\n/* harmony import */ var _Users_leonelsentana_Robyn_docs_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var _Users_leonelsentana_Robyn_docs_node_modules_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);\n/* harmony import */ var _docusaurus_useBaseUrl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(90);\nvar frontMatter={id:'calibration',title:'Calibration using experimental results'};var metadata={\"unversionedId\":\"calibration\",\"id\":\"calibration\",\"isDocsHomePage\":false,\"title\":\"Calibration using experimental results\",\"description\":\"Calibration concept\",\"source\":\"@site/docs/calibration.md\",\"slug\":\"/calibration\",\"permalink\":\"/Robyn/docs/calibration\",\"editUrl\":\"https://github.com/facebookexperimental/Robyn/docs/calibration.md\",\"version\":\"current\",\"sidebar\":\"someSidebar\",\"previous\":{\"title\":\"Automated hyperparameter selection and optimization\",\"permalink\":\"/Robyn/docs/automated-hyperparameter-selection-optimization\"},\"next\":{\"title\":\"Outputs and diagnostics\",\"permalink\":\"/Robyn/docs/outputs-diagnostics\"}};/* @jsxRuntime classic */ /* @jsx mdx */var toc=[{value:'Calibration concept',id:'calibration-concept',children:[]},{value:'Calibration in the code',id:'calibration-in-the-code',children:[]}];var layoutProps={toc:toc};var MDXLayout=\"wrapper\";function MDXContent(_ref){var components=_ref.components,props=Object(_Users_leonelsentana_Robyn_docs_node_modules_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(_ref,[\"components\"]);return Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(MDXLayout,Object(_Users_leonelsentana_Robyn_docs_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])({},layoutProps,props,{components:components,mdxType:\"MDXLayout\"}),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"h3\",{\"id\":\"calibration-concept\"},\"Calibration concept\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"By applying results from randomized controlled-experiments, you may improve the\\naccuracy of your marketing mix models dramatically. It is recommended to run\\nthese on a recurrent basis to keep the model calibrated permanently. In general,\\nwe want to compare the experiment result with the MMM estimation of a marketing\\nchannel. Conceptually, this method is like a Bayesian method, in which we use\\nexperiment results as a prior to shrink the coefficients of media variables. A\\ngood example of these types of experiments is Facebook\\u2019s conversion lift tool\\nwhich can help guide the model towards a specific range of incremental values.\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"img\",{alt:\"Calibration chart\",src:Object(_docusaurus_useBaseUrl__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])('/img/calibration1.png')}),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"Figure illustrates the calibration process above for one MMM candidate model.\\nTable below illustrates the model selection output including FB lift calibration\\nelement. Modelers can select the top models with relatively small MAPE metrics\\nas the candidates for the final model. In this example, we suggest picking model\\ntwo, as it has the minimum \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"em\",null,\"MAPE(cal,fb)\"),\" and its \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"em\",null,\"MAPE(holdout)\"),\"\\nis only 0.4% more than the minimum one.\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"h4\",{\"id\":\"example-table\"},\"Example Table\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"Sample output of model selection of a MMM with only two media channels, TV and\\nSocial \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"img\",{alt:\"Calibration table\",src:Object(_docusaurus_useBaseUrl__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])('/img/calibration2.png')})),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"Note that \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"em\",null,\"MAPE(cal,fb)\"),\" will likely vary more widely than\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"em\",null,\"MAPE(holdout)\"),\" . Given this, calibration can improve performance without substantially sacrificing backtesting performance. This calibration method can be applied to other media channels which run experiments, the more channels that are calibrated, the more accurate the MMM model. \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"em\",null,\"You may find the calibration function in the \\u2018func.R\\u2019 script.\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"h3\",{\"id\":\"calibration-in-the-code\"},\"Calibration in the code\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"So, how do we apply this in our code?\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"ol\",null,Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"li\",{parentName:\"ol\"},\"First, we check if media channels to be calibrated actually have a media\\nvariable created.\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"li\",{parentName:\"ol\"},\"After that, we collect all different media to be calibrated. Consequently, we\\nloop over each lift channel (Where for each of them we iterate over all\\ndifferent studies if more than one, determining the date range of each study)\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"li\",{parentName:\"ol\"},\"In addition, we convert data from weeks to days (Please note the \",\"*\",\"7 in the\\nformula for mmmDays, this is assuming you will use weekly data as a basis for\\nyour model).\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"li\",{parentName:\"ol\"},\"Finally, and once both lift study and MMM dates are both in days, we scale\\nthe total decomposed model predicted sales into the exact number of days the\\nlift study had to be comparable with previously uploaded liftAbs number under\\nthe set_lift variable (remember liftAbs values in set_lift variable have to\\nbe absolute and measuring the same metric as the model does ie. total\\nincremental sales vs. model predicted sales)\")),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"pre\",null,Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"code\",{parentName:\"pre\"},\"#### Define lift calibration function\\nf.calibrateLift <- function(decompCollect, set_lift) {\\n\\n  check_set_lift <- any(sapply(set_lift$channel, function(x) any(str_detect(x, set_mediaVarName)))==F) #check if any lift channel doesn't have media var\\n  if (check_set_lift) {stop(\\\"set_lift channels must have media variable\\\")}\\n  ## prep lift input\\n  getLiftMedia <- unique(set_lift$channel)\\n  getDecompVec <- decompCollect$xDecompVec\\n\\n  ## loop all lift input\\n  liftCollect <- list()\\n  for (m in 1:length(getLiftMedia)) { # loop per lift channel\\n\\n    liftWhich <- str_which(set_lift$channel, getLiftMedia[m])\\n\\n    liftCollect2 <- list()\\n    for (lw in 1:length(liftWhich)) { # loop per lift test per channel\\n\\n      ## get lift period subset\\n      liftStart <- set_lift[liftWhich[lw], liftStartDate]\\n      liftEnd <- set_lift[liftWhich[lw], liftEndDate]\\n      liftPeriodVec <- getDecompVec[DS >= liftStart & DS <= liftEnd, c(\\\"DS\\\", getLiftMedia[m]), with = F]\\n\\n      ## scale decomp\\n      mmmDays <- nrow(liftPeriodVec) * 7\\n      liftDays <- as.integer(liftEnd- liftStart + 1)\\n      y_hatLift <- sum(unlist(getDecompVec[, -1])) # total pred sales\\n      x_decompLift <- sum(liftPeriodVec[,2])\\n      x_decompLiftScaled <- x_decompLift / mmmDays * liftDays\\n\\n      ## output\\n      liftCollect2[[lw]] <- data.table(liftMedia = getLiftMedia[m] ,\\n                                       liftStart = liftStart,\\n                                       liftEnd = liftEnd,\\n                                       liftAbs = set_lift[liftWhich[lw], liftAbs],\\n                                       decompAbsScaled = x_decompLiftScaled)\\n    }\\n    liftCollect[[m]] <- rbindlist(liftCollect2)\\n  }\\n\")),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"p\",null,\"The last step is to calculate the MAPE. This will be the key metric to define\\nthe model that is closest to actual incremental sales during periods for the\\nlift study. It will therefore allow us to make a decision as per the example on\\nthe \",Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"a\",{parentName:\"p\",\"href\":\"#example-table\"},Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"strong\",{parentName:\"a\"},\"table\")),\".\"),Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"pre\",null,Object(_mdx_js_react__WEBPACK_IMPORTED_MODULE_3__[/* mdx */ \"b\"])(\"code\",{parentName:\"pre\"},\"  ## get mape_lift\\n  liftCollect <- rbindlist(liftCollect)[, mape_lift := abs((decompAbsScaled - liftAbs) / liftAbs) * 100]\\n  return(liftCollect)\\n}\\n\")));};MDXContent.isMDXComponent=true;\n\n/***/ }),\n\n/***/ 88:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export MDXContext */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MDXProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createElement; });\n/* unused harmony export useMDXComponents */\n/* unused harmony export withMDXComponents */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar isFunction = function isFunction(obj) {\n  return typeof obj === 'function';\n};\n\nvar MDXContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({});\nvar withMDXComponents = function withMDXComponents(Component) {\n  return function (props) {\n    var allComponents = useMDXComponents(props.components);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({}, props, {\n      components: allComponents\n    }));\n  };\n};\nvar useMDXComponents = function useMDXComponents(components) {\n  var contextComponents = react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(MDXContext);\n  var allComponents = contextComponents;\n\n  if (components) {\n    allComponents = isFunction(components) ? components(contextComponents) : _objectSpread2(_objectSpread2({}, contextComponents), components);\n  }\n\n  return allComponents;\n};\nvar MDXProvider = function MDXProvider(props) {\n  var allComponents = useMDXComponents(props.components);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MDXContext.Provider, {\n    value: allComponents\n  }, props.children);\n};\n\nvar TYPE_PROP_NAME = 'mdxType';\nvar DEFAULTS = {\n  inlineCode: 'code',\n  wrapper: function wrapper(_ref) {\n    var children = _ref.children;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, {}, children);\n  }\n};\nvar MDXCreateElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef(function (props, ref) {\n  var propComponents = props.components,\n      mdxType = props.mdxType,\n      originalType = props.originalType,\n      parentName = props.parentName,\n      etc = _objectWithoutProperties(props, [\"components\", \"mdxType\", \"originalType\", \"parentName\"]);\n\n  var components = useMDXComponents(propComponents);\n  var type = mdxType;\n  var Component = components[\"\".concat(parentName, \".\").concat(type)] || components[type] || DEFAULTS[type] || originalType;\n\n  if (propComponents) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _objectSpread2(_objectSpread2({\n      ref: ref\n    }, etc), {}, {\n      components: propComponents\n    }));\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _objectSpread2({\n    ref: ref\n  }, etc));\n});\nMDXCreateElement.displayName = 'MDXCreateElement';\nfunction createElement (type, props) {\n  var args = arguments;\n  var mdxType = props && props.mdxType;\n\n  if (typeof type === 'string' || mdxType) {\n    var argsLength = args.length;\n    var createElementArgArray = new Array(argsLength);\n    createElementArgArray[0] = MDXCreateElement;\n    var newProps = {};\n\n    for (var key in props) {\n      if (hasOwnProperty.call(props, key)) {\n        newProps[key] = props[key];\n      }\n    }\n\n    newProps.originalType = type;\n    newProps[TYPE_PROP_NAME] = typeof type === 'string' ? type : mdxType;\n    createElementArgArray[1] = newProps;\n\n    for (var i = 2; i < argsLength; i++) {\n      createElementArgArray[i] = args[i];\n    }\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement.apply(null, createElementArgArray);\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement.apply(null, args);\n}\n\n\n\n\n/***/ }),\n\n/***/ 90:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return useBaseUrlUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return useBaseUrl; });\n/* harmony import */ var _useDocusaurusContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);\n/* harmony import */ var _isInternalUrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function addBaseUrl(siteUrl,baseUrl,url,{forcePrependBaseUrl=false,absolute=false}={}){if(!url){return url;}// it never makes sense to add a base url to a local anchor url\nif(url.startsWith('#')){return url;}// it never makes sense to add a base url to an url with a protocol\nif(Object(_isInternalUrl__WEBPACK_IMPORTED_MODULE_1__[/* hasProtocol */ \"b\"])(url)){return url;}if(forcePrependBaseUrl){return baseUrl+url;}// We should avoid adding the baseurl twice if it's already there\nconst shouldAddBaseUrl=!url.startsWith(baseUrl);const basePath=shouldAddBaseUrl?baseUrl+url.replace(/^\\//,''):url;return absolute?siteUrl+basePath:basePath;}function useBaseUrlUtils(){const{siteConfig:{baseUrl='/',url:siteUrl}={}}=Object(_useDocusaurusContext__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();return{withBaseUrl:(url,options)=>{return addBaseUrl(siteUrl,baseUrl,url,options);}};}function useBaseUrl(url,options={}){const{withBaseUrl}=useBaseUrlUtils();return withBaseUrl(url,options);}\n\n/***/ }),\n\n/***/ 92:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return hasProtocol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isInternalUrl; });\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function hasProtocol(url){return /^(\\w*:|\\/\\/)/.test(url)===true;}function isInternalUrl(url){return typeof url!=='undefined'&&!hasProtocol(url);}\n\n/***/ })\n\n}]);","inputSourceMap":null}